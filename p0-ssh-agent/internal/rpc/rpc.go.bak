package rpc

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"sync"
	"sync/atomic"
	"time"

	"github.com/ethereum/go-ethereum/rpc"
)

// MethodHandler is a function that handles RPC method calls
type MethodHandler func(ctx context.Context, params interface{}) (interface{}, error)

// Client handles JSON-RPC communication using ethereum/go-ethereum/rpc
type Client struct {
	mu           sync.RWMutex
	methods      map[string]MethodHandler
	server       *rpc.Server
	client       *rpc.Client
	ctx          context.Context
	cancel       context.CancelFunc
	sendFunc     func([]byte) error
	nextID       int64
	pendingCalls map[interface{}]chan *Response
}

// rpcService handles method calls for ethereum RPC
type rpcService struct {
	client *Client
}

// NewClient creates a new JSON-RPC client using ethereum/go-ethereum/rpc
func NewClient(sendFunc func([]byte) error) *Client {
	ctx, cancel := context.WithCancel(context.Background())
	
	client := &Client{
		methods:      make(map[string]MethodHandler),
		pendingCalls: make(map[interface{}]chan *Response),
		ctx:          ctx,
		cancel:       cancel,
		sendFunc:     sendFunc,
	}
	
	// Create RPC server for incoming method calls (optional - can be removed if not needed)
	client.server = rpc.NewServer()
	service := &rpcService{client: client}
	client.server.RegisterName("rpc", service)
	client.client = rpc.DialInProc(client.server)
	
	return client
}

// AddMethod registers a method handler
func (c *Client) AddMethod(method string, handler MethodHandler) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.methods[method] = handler
}

// Call makes a JSON-RPC call by sending over WebSocket
func (c *Client) Call(method string, params interface{}) (interface{}, error) {
	id := atomic.AddInt64(&c.nextID, 1)
	
	request := Request{
		JSONRPC: "2.0",
		Method:  method,
		Params:  params,
		ID:      id,
	}
	
	data, err := json.Marshal(request)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}
	
	log.Printf("[RPC DEBUG] Sending request: %s", string(data))
	
	// Create response channel
	respChan := make(chan *Response, 1)
	c.mu.Lock()
	c.pendingCalls[id] = respChan
	log.Printf("[RPC DEBUG] Added pending call for ID: %v, total pending: %d", id, len(c.pendingCalls))
	c.mu.Unlock()
	
	// Send request over WebSocket
	if err := c.sendFunc(data); err != nil {
		c.mu.Lock()
		delete(c.pendingCalls, id)
		c.mu.Unlock()
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	
	log.Printf("[RPC DEBUG] Waiting for response to ID: %v", id)
	
	// Wait for response with timeout
	select {
	case response := <-respChan:
		log.Printf("[RPC DEBUG] Received response for ID: %v", id)
		if response.Error != nil {
			return nil, fmt.Errorf("RPC error %d: %s", response.Error.Code, response.Error.Message)
		}
		return response.Result, nil
	case <-time.After(30 * time.Second):
		log.Printf("[RPC DEBUG] Timeout waiting for response to ID: %v", id)
		c.mu.Lock()
		delete(c.pendingCalls, id)
		c.mu.Unlock()
		return nil, fmt.Errorf("RPC call timeout")
	case <-c.ctx.Done():
		log.Printf("[RPC DEBUG] Context cancelled while waiting for response to ID: %v", id)
		c.mu.Lock()
		delete(c.pendingCalls, id)
		c.mu.Unlock()
		return nil, c.ctx.Err()
	}
}

// Request represents a JSON-RPC 2.0 request
type Request struct {
	JSONRPC string      `json:"jsonrpc"`
	Method  string      `json:"method"`
	Params  interface{} `json:"params,omitempty"`
	ID      interface{} `json:"id"`
}

// Response represents a JSON-RPC 2.0 response
type Response struct {
	JSONRPC string      `json:"jsonrpc"`
	Result  interface{} `json:"result,omitempty"`
	Error   *RPCError   `json:"error,omitempty"`
	ID      interface{} `json:"id"`
}

// RPCError represents a JSON-RPC 2.0 error
type RPCError struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

// HandleMessage processes incoming JSON-RPC messages
func (c *Client) HandleMessage(data []byte) error {
	log.Printf("[RPC DEBUG] Received message: %s", string(data))
	
	// Try to parse as response first (for our outbound calls)
	var response Response
	if err := json.Unmarshal(data, &response); err == nil && response.ID != nil {
		log.Printf("[RPC DEBUG] Parsed as response: ID=%v, Result=%v, Error=%v", response.ID, response.Result, response.Error)
		return c.handleResponse(&response)
	}
	
	// Try to parse as request (incoming method calls)
	var request Request
	if err := json.Unmarshal(data, &request); err == nil && request.Method != "" {
		log.Printf("[RPC DEBUG] Parsed as request: Method=%s, ID=%v", request.Method, request.ID)
		return c.handleRequest(&request)
	}
	
	log.Printf("[RPC DEBUG] Failed to parse message as request or response")
	return fmt.Errorf("invalid JSON-RPC message")
}

// handleResponse handles incoming responses to our outbound calls
func (c *Client) handleResponse(response *Response) error {
	log.Printf("[RPC DEBUG] Handling response for ID: %v", response.ID)
	
	c.mu.Lock()
	respChan, exists := c.pendingCalls[response.ID]
	if exists {
		delete(c.pendingCalls, response.ID)
	}
	log.Printf("[RPC DEBUG] Pending calls count: %d, found channel: %t", len(c.pendingCalls), exists)
	c.mu.Unlock()
	
	if exists {
		log.Printf("[RPC DEBUG] Sending response to channel")
		respChan <- response
		return nil
	}
	
	log.Printf("[RPC DEBUG] No pending call found for ID %v", response.ID)
	return fmt.Errorf("unexpected response with ID %v", response.ID)
}

// handleRequest handles incoming method calls
func (c *Client) handleRequest(request *Request) error {
	c.mu.RLock()
	handler, exists := c.methods[request.Method]
	c.mu.RUnlock()
	
	var response Response
	response.JSONRPC = "2.0"
	response.ID = request.ID
	
	if !exists {
		response.Error = &RPCError{
			Code:    -32601,
			Message: "Method not found",
		}
	} else {
		result, err := handler(c.ctx, request.Params)
		if err != nil {
			response.Error = &RPCError{
				Code:    -32603,
				Message: "Internal error",
				Data:    err.Error(),
			}
		} else {
			response.Result = result
		}
	}
	
	// Send response
	data, err := json.Marshal(response)
	if err != nil {
		return fmt.Errorf("failed to marshal response: %w", err)
	}
	
	return c.sendFunc(data)
}

// Close closes the client connections
func (c *Client) Close() error {
	c.cancel()

	// Close all pending call channels
	c.mu.Lock()
	for _, ch := range c.pendingCalls {
		close(ch)
	}
	c.pendingCalls = make(map[interface{}]chan *Response)
	c.mu.Unlock()

	if c.client != nil {
		c.client.Close()
	}
	if c.server != nil {
		c.server.Stop()
	}
	return nil
}

// The rpcService is kept minimal since we handle incoming requests manually
// but use ethereum RPC for outbound calls